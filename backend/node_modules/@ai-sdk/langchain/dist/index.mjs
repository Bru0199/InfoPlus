// src/adapter.ts
import {
  SystemMessage
} from "@langchain/core/messages";
import {
  convertToModelMessages
} from "ai";

// src/utils.ts
import {
  AIMessage,
  HumanMessage,
  ToolMessage,
  AIMessageChunk
} from "@langchain/core/messages";
function convertToolResultPart(block) {
  const content = (() => {
    if (block.output.type === "text" || block.output.type === "error-text") {
      return block.output.value;
    }
    if (block.output.type === "json" || block.output.type === "error-json") {
      return JSON.stringify(block.output.value);
    }
    if (block.output.type === "content") {
      return block.output.value.map((outputBlock) => {
        if (outputBlock.type === "text") {
          return outputBlock.text;
        }
        return "";
      }).join("");
    }
    return "";
  })();
  return new ToolMessage({
    tool_call_id: block.toolCallId,
    content
  });
}
function convertAssistantContent(content) {
  if (typeof content === "string") {
    return new AIMessage({ content });
  }
  const textParts = [];
  const toolCalls = [];
  for (const part of content) {
    if (part.type === "text") {
      textParts.push(part.text);
    } else if (part.type === "tool-call") {
      toolCalls.push({
        id: part.toolCallId,
        name: part.toolName,
        args: part.input
      });
    }
  }
  return new AIMessage({
    content: textParts.join(""),
    tool_calls: toolCalls.length > 0 ? toolCalls : void 0
  });
}
function getDefaultFilename(mediaType, prefix = "file") {
  const ext = mediaType.split("/")[1] || "bin";
  return `${prefix}.${ext}`;
}
function convertUserContent(content) {
  var _a;
  if (typeof content === "string") {
    return new HumanMessage({ content });
  }
  const contentBlocks = [];
  for (const part of content) {
    if (part.type === "text") {
      contentBlocks.push({ type: "text", text: part.text });
    } else if (part.type === "image") {
      const imagePart = part;
      if (imagePart.image instanceof URL) {
        contentBlocks.push({
          type: "image_url",
          image_url: { url: imagePart.image.toString() }
        });
      } else if (typeof imagePart.image === "string") {
        if (imagePart.image.startsWith("http://") || imagePart.image.startsWith("https://") || imagePart.image.startsWith("data:")) {
          contentBlocks.push({
            type: "image_url",
            image_url: { url: imagePart.image }
          });
        } else {
          const mimeType = imagePart.mediaType || "image/png";
          contentBlocks.push({
            type: "image_url",
            image_url: { url: `data:${mimeType};base64,${imagePart.image}` }
          });
        }
      } else if (
        /**
         * Handle Uint8Array or ArrayBuffer (binary data)
         */
        imagePart.image instanceof Uint8Array || imagePart.image instanceof ArrayBuffer
      ) {
        const bytes = imagePart.image instanceof ArrayBuffer ? new Uint8Array(imagePart.image) : imagePart.image;
        const base64 = btoa(String.fromCharCode(...bytes));
        const mimeType = imagePart.mediaType || "image/png";
        contentBlocks.push({
          type: "image_url",
          image_url: { url: `data:${mimeType};base64,${base64}` }
        });
      }
    } else if (part.type === "file") {
      const filePart = part;
      const isImage = (_a = filePart.mediaType) == null ? void 0 : _a.startsWith("image/");
      if (isImage) {
        if (filePart.data instanceof URL) {
          contentBlocks.push({
            type: "image_url",
            image_url: { url: filePart.data.toString() }
          });
        } else if (typeof filePart.data === "string") {
          if (filePart.data.startsWith("http://") || filePart.data.startsWith("https://") || filePart.data.startsWith("data:")) {
            contentBlocks.push({
              type: "image_url",
              image_url: { url: filePart.data }
            });
          } else {
            contentBlocks.push({
              type: "image_url",
              image_url: {
                url: `data:${filePart.mediaType};base64,${filePart.data}`
              }
            });
          }
        } else if (filePart.data instanceof Uint8Array || filePart.data instanceof ArrayBuffer) {
          const bytes = filePart.data instanceof ArrayBuffer ? new Uint8Array(filePart.data) : filePart.data;
          const base64 = btoa(String.fromCharCode(...bytes));
          contentBlocks.push({
            type: "image_url",
            image_url: { url: `data:${filePart.mediaType};base64,${base64}` }
          });
        }
      } else {
        const filename = filePart.filename || getDefaultFilename(filePart.mediaType, "file");
        if (filePart.data instanceof URL) {
          contentBlocks.push({
            type: "file",
            url: filePart.data.toString(),
            mimeType: filePart.mediaType,
            filename
          });
        } else if (typeof filePart.data === "string") {
          if (filePart.data.startsWith("http://") || filePart.data.startsWith("https://")) {
            contentBlocks.push({
              type: "file",
              url: filePart.data,
              mimeType: filePart.mediaType,
              filename
            });
          } else if (filePart.data.startsWith("data:")) {
            const matches = filePart.data.match(/^data:([^;]+);base64,(.+)$/);
            if (matches) {
              contentBlocks.push({
                type: "file",
                data: matches[2],
                mimeType: matches[1],
                filename
              });
            } else {
              contentBlocks.push({
                type: "file",
                url: filePart.data,
                mimeType: filePart.mediaType,
                filename
              });
            }
          } else {
            contentBlocks.push({
              type: "file",
              data: filePart.data,
              mimeType: filePart.mediaType,
              filename
            });
          }
        } else if (filePart.data instanceof Uint8Array || filePart.data instanceof ArrayBuffer) {
          const bytes = filePart.data instanceof ArrayBuffer ? new Uint8Array(filePart.data) : filePart.data;
          const base64 = btoa(String.fromCharCode(...bytes));
          contentBlocks.push({
            type: "file",
            data: base64,
            mimeType: filePart.mediaType,
            filename
          });
        }
      }
    }
  }
  if (contentBlocks.every((block) => block.type === "text")) {
    return new HumanMessage({
      content: contentBlocks.map((block) => block.text).join("")
    });
  }
  return new HumanMessage({ content: contentBlocks });
}
function isToolResultPart(item) {
  return item != null && typeof item === "object" && "type" in item && item.type === "tool-result";
}
function processModelChunk(chunk, state, controller) {
  var _a, _b, _c;
  if (!state.emittedImages) {
    state.emittedImages = /* @__PURE__ */ new Set();
  }
  if (chunk.id) {
    state.messageId = chunk.id;
  }
  const chunkObj = chunk;
  const additionalKwargs = chunkObj.additional_kwargs;
  const imageOutputs = extractImageOutputs(additionalKwargs);
  for (const imageOutput of imageOutputs) {
    if (imageOutput.result && !state.emittedImages.has(imageOutput.id)) {
      state.emittedImages.add(imageOutput.id);
      const mediaType = `image/${imageOutput.output_format || "png"}`;
      controller.enqueue({
        type: "file",
        mediaType,
        url: `data:${mediaType};base64,${imageOutput.result}`
      });
      state.started = true;
    }
  }
  const reasoning = extractReasoningFromContentBlocks(chunk) || extractReasoningFromValuesMessage(chunk);
  if (reasoning) {
    if (!state.reasoningStarted) {
      state.reasoningMessageId = state.messageId;
      controller.enqueue({ type: "reasoning-start", id: state.messageId });
      state.reasoningStarted = true;
      state.started = true;
    }
    controller.enqueue({
      type: "reasoning-delta",
      delta: reasoning,
      id: (_a = state.reasoningMessageId) != null ? _a : state.messageId
    });
  }
  const text = typeof chunk.content === "string" ? chunk.content : Array.isArray(chunk.content) ? chunk.content.filter(
    (c) => typeof c === "object" && c !== null && "type" in c && c.type === "text"
  ).map((c) => c.text).join("") : "";
  if (text) {
    if (state.reasoningStarted && !state.textStarted) {
      controller.enqueue({
        type: "reasoning-end",
        id: (_b = state.reasoningMessageId) != null ? _b : state.messageId
      });
      state.reasoningStarted = false;
    }
    if (!state.textStarted) {
      state.textMessageId = state.messageId;
      controller.enqueue({ type: "text-start", id: state.messageId });
      state.textStarted = true;
      state.started = true;
    }
    controller.enqueue({
      type: "text-delta",
      delta: text,
      id: (_c = state.textMessageId) != null ? _c : state.messageId
    });
  }
}
function isPlainMessageObject(msg) {
  if (msg == null || typeof msg !== "object") return false;
  return typeof msg._getType !== "function";
}
function getMessageId(msg) {
  if (msg == null || typeof msg !== "object") return void 0;
  const msgObj = msg;
  if (typeof msgObj.id === "string") {
    return msgObj.id;
  }
  if (msgObj.type === "constructor" && msgObj.kwargs && typeof msgObj.kwargs === "object") {
    const kwargs = msgObj.kwargs;
    if (typeof kwargs.id === "string") {
      return kwargs.id;
    }
  }
  return void 0;
}
function isAIMessageChunk(msg) {
  if (AIMessageChunk.isInstance(msg)) return true;
  if (isPlainMessageObject(msg)) {
    const obj = msg;
    if ("type" in obj && obj.type === "ai") return true;
    if (obj.type === "constructor" && Array.isArray(obj.id) && (obj.id.includes("AIMessageChunk") || obj.id.includes("AIMessage"))) {
      return true;
    }
  }
  return false;
}
function isToolMessageType(msg) {
  if (ToolMessage.isInstance(msg)) return true;
  if (isPlainMessageObject(msg)) {
    const obj = msg;
    if ("type" in obj && obj.type === "tool") return true;
    if (obj.type === "constructor" && Array.isArray(obj.id) && obj.id.includes("ToolMessage")) {
      return true;
    }
  }
  return false;
}
function getMessageText(msg) {
  var _a;
  if (AIMessageChunk.isInstance(msg)) {
    return (_a = msg.text) != null ? _a : "";
  }
  if (msg == null || typeof msg !== "object") return "";
  const msgObj = msg;
  const dataSource = msgObj.type === "constructor" && msgObj.kwargs && typeof msgObj.kwargs === "object" ? msgObj.kwargs : msgObj;
  if ("content" in dataSource) {
    const content = dataSource.content;
    if (typeof content === "string") {
      return content;
    }
    if (Array.isArray(content)) {
      return content.filter(
        (block) => block != null && typeof block === "object" && block.type === "text" && typeof block.text === "string"
      ).map((block) => block.text).join("");
    }
    return "";
  }
  return "";
}
function isReasoningContentBlock(obj) {
  return obj != null && typeof obj === "object" && "type" in obj && obj.type === "reasoning" && "reasoning" in obj && typeof obj.reasoning === "string";
}
function isThinkingContentBlock(obj) {
  return obj != null && typeof obj === "object" && "type" in obj && obj.type === "thinking" && "thinking" in obj && typeof obj.thinking === "string";
}
function isGPT5ReasoningOutput(obj) {
  return obj != null && typeof obj === "object" && "type" in obj && obj.type === "reasoning" && "summary" in obj && Array.isArray(obj.summary);
}
function extractReasoningId(msg) {
  var _a;
  if (msg == null || typeof msg !== "object") return void 0;
  const msgObj = msg;
  const kwargs = msgObj.kwargs && typeof msgObj.kwargs === "object" ? msgObj.kwargs : msgObj;
  const additionalKwargs = kwargs.additional_kwargs;
  if ((_a = additionalKwargs == null ? void 0 : additionalKwargs.reasoning) == null ? void 0 : _a.id) {
    return additionalKwargs.reasoning.id;
  }
  const responseMetadata = kwargs.response_metadata;
  if (responseMetadata && Array.isArray(responseMetadata.output)) {
    for (const item of responseMetadata.output) {
      if (isGPT5ReasoningOutput(item)) {
        return item.id;
      }
    }
  }
  return void 0;
}
function extractReasoningFromContentBlocks(msg) {
  if (msg == null || typeof msg !== "object") return void 0;
  const msgObj = msg;
  const kwargs = msgObj.kwargs && typeof msgObj.kwargs === "object" ? msgObj.kwargs : msgObj;
  const contentBlocks = kwargs.contentBlocks;
  if (Array.isArray(contentBlocks)) {
    const reasoningParts = [];
    for (const block of contentBlocks) {
      if (isReasoningContentBlock(block)) {
        reasoningParts.push(block.reasoning);
      } else if (isThinkingContentBlock(block)) {
        reasoningParts.push(block.thinking);
      }
    }
    if (reasoningParts.length > 0) {
      return reasoningParts.join("");
    }
  }
  const additionalKwargs = kwargs.additional_kwargs;
  if ((additionalKwargs == null ? void 0 : additionalKwargs.reasoning) && Array.isArray(additionalKwargs.reasoning.summary)) {
    const reasoningParts = [];
    for (const summaryItem of additionalKwargs.reasoning.summary) {
      if (typeof summaryItem === "object" && summaryItem !== null && "text" in summaryItem && typeof summaryItem.text === "string") {
        reasoningParts.push(summaryItem.text);
      }
    }
    if (reasoningParts.length > 0) {
      return reasoningParts.join("");
    }
  }
  return void 0;
}
function extractReasoningFromValuesMessage(msg) {
  if (msg == null || typeof msg !== "object") return void 0;
  const msgObj = msg;
  const kwargs = msgObj.kwargs && typeof msgObj.kwargs === "object" ? msgObj.kwargs : msgObj;
  const responseMetadata = kwargs.response_metadata;
  if (responseMetadata && Array.isArray(responseMetadata.output)) {
    const reasoningParts = [];
    for (const item of responseMetadata.output) {
      if (isGPT5ReasoningOutput(item)) {
        for (const summaryItem of item.summary) {
          if (typeof summaryItem === "object" && summaryItem !== null) {
            const text = summaryItem.text;
            if (typeof text === "string" && text) {
              reasoningParts.push(text);
            }
          }
        }
      }
    }
    if (reasoningParts.length > 0) {
      return reasoningParts.join("");
    }
  }
  const additionalKwargs = kwargs.additional_kwargs;
  if ((additionalKwargs == null ? void 0 : additionalKwargs.reasoning) && Array.isArray(additionalKwargs.reasoning.summary)) {
    const reasoningParts = [];
    for (const summaryItem of additionalKwargs.reasoning.summary) {
      if (typeof summaryItem === "object" && summaryItem !== null && "text" in summaryItem && typeof summaryItem.text === "string") {
        reasoningParts.push(summaryItem.text);
      }
    }
    if (reasoningParts.length > 0) {
      return reasoningParts.join("");
    }
  }
  return void 0;
}
function isImageGenerationOutput(obj) {
  return obj != null && typeof obj === "object" && "type" in obj && obj.type === "image_generation_call";
}
function extractImageOutputs(additionalKwargs) {
  if (!additionalKwargs) return [];
  const toolOutputs = additionalKwargs.tool_outputs;
  if (!Array.isArray(toolOutputs)) return [];
  return toolOutputs.filter(isImageGenerationOutput);
}
function processLangGraphEvent(event, state, controller) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x;
  const {
    messageSeen,
    messageConcat,
    emittedToolCalls,
    emittedImages,
    emittedReasoningIds,
    messageReasoningIds,
    toolCallInfoByIndex,
    emittedToolCallsByKey
  } = state;
  const [type, data] = event.length === 3 ? event.slice(1) : event;
  switch (type) {
    case "custom": {
      let customTypeName = "custom";
      let partId;
      if (data != null && typeof data === "object" && !Array.isArray(data)) {
        const dataObj = data;
        if (typeof dataObj.type === "string" && dataObj.type) {
          customTypeName = dataObj.type;
        }
        if (typeof dataObj.id === "string" && dataObj.id) {
          partId = dataObj.id;
        }
      }
      controller.enqueue({
        type: `data-${customTypeName}`,
        id: partId,
        transient: partId == null,
        data
      });
      break;
    }
    case "messages": {
      const [rawMsg, metadata] = data;
      const msg = rawMsg;
      const msgId = getMessageId(msg);
      if (!msgId) return;
      const langgraphStep = typeof (metadata == null ? void 0 : metadata.langgraph_step) === "number" ? metadata.langgraph_step : null;
      if (langgraphStep !== null && langgraphStep !== state.currentStep) {
        if (state.currentStep !== null) {
          controller.enqueue({ type: "finish-step" });
        }
        controller.enqueue({ type: "start-step" });
        state.currentStep = langgraphStep;
      }
      if (AIMessageChunk.isInstance(msg)) {
        if (messageConcat[msgId]) {
          messageConcat[msgId] = messageConcat[msgId].concat(
            msg
          );
        } else {
          messageConcat[msgId] = msg;
        }
      }
      if (isAIMessageChunk(msg)) {
        const concatChunk = messageConcat[msgId];
        const msgObj = msg;
        const dataSource = msgObj.type === "constructor" && msgObj.kwargs && typeof msgObj.kwargs === "object" ? msgObj.kwargs : msgObj;
        const additionalKwargs = dataSource.additional_kwargs;
        const imageOutputs = extractImageOutputs(additionalKwargs);
        for (const imageOutput of imageOutputs) {
          if (imageOutput.result && !emittedImages.has(imageOutput.id)) {
            emittedImages.add(imageOutput.id);
            const mediaType = `image/${imageOutput.output_format || "png"}`;
            controller.enqueue({
              type: "file",
              mediaType,
              url: `data:${mediaType};base64,${imageOutput.result}`
            });
          }
        }
        const toolCallChunks = dataSource.tool_call_chunks;
        if (toolCallChunks == null ? void 0 : toolCallChunks.length) {
          for (const toolCallChunk of toolCallChunks) {
            const idx = (_a = toolCallChunk.index) != null ? _a : 0;
            if (toolCallChunk.id) {
              (_b = toolCallInfoByIndex[msgId]) != null ? _b : toolCallInfoByIndex[msgId] = {};
              toolCallInfoByIndex[msgId][idx] = {
                id: toolCallChunk.id,
                name: toolCallChunk.name || ((_d = (_c = concatChunk == null ? void 0 : concatChunk.tool_call_chunks) == null ? void 0 : _c[idx]) == null ? void 0 : _d.name) || "unknown"
              };
            }
            const toolCallId = toolCallChunk.id || ((_f = (_e = toolCallInfoByIndex[msgId]) == null ? void 0 : _e[idx]) == null ? void 0 : _f.id) || ((_h = (_g = concatChunk == null ? void 0 : concatChunk.tool_call_chunks) == null ? void 0 : _g[idx]) == null ? void 0 : _h.id);
            if (!toolCallId) {
              continue;
            }
            const toolName = toolCallChunk.name || ((_j = (_i = toolCallInfoByIndex[msgId]) == null ? void 0 : _i[idx]) == null ? void 0 : _j.name) || ((_l = (_k = concatChunk == null ? void 0 : concatChunk.tool_call_chunks) == null ? void 0 : _k[idx]) == null ? void 0 : _l.name) || "unknown";
            if (!((_n = (_m = messageSeen[msgId]) == null ? void 0 : _m.tool) == null ? void 0 : _n[toolCallId])) {
              controller.enqueue({
                type: "tool-input-start",
                toolCallId,
                toolName,
                dynamic: true
              });
              (_o = messageSeen[msgId]) != null ? _o : messageSeen[msgId] = {};
              (_q = (_p = messageSeen[msgId]).tool) != null ? _q : _p.tool = {};
              messageSeen[msgId].tool[toolCallId] = true;
              emittedToolCalls.add(toolCallId);
            }
            if (toolCallChunk.args) {
              controller.enqueue({
                type: "tool-input-delta",
                toolCallId,
                inputTextDelta: toolCallChunk.args
              });
            }
          }
          return;
        }
        const chunkReasoningId = extractReasoningId(msg);
        if (chunkReasoningId) {
          if (!messageReasoningIds[msgId]) {
            messageReasoningIds[msgId] = chunkReasoningId;
          }
          emittedReasoningIds.add(chunkReasoningId);
        }
        const reasoning = extractReasoningFromContentBlocks(msg);
        if (reasoning) {
          const reasoningId = (_s = (_r = messageReasoningIds[msgId]) != null ? _r : chunkReasoningId) != null ? _s : msgId;
          if (!((_t = messageSeen[msgId]) == null ? void 0 : _t.reasoning)) {
            controller.enqueue({ type: "reasoning-start", id: msgId });
            (_u = messageSeen[msgId]) != null ? _u : messageSeen[msgId] = {};
            messageSeen[msgId].reasoning = true;
          }
          controller.enqueue({
            type: "reasoning-delta",
            delta: reasoning,
            id: msgId
          });
          emittedReasoningIds.add(reasoningId);
        }
        const text = getMessageText(msg);
        if (text) {
          if (!((_v = messageSeen[msgId]) == null ? void 0 : _v.text)) {
            controller.enqueue({ type: "text-start", id: msgId });
            (_w = messageSeen[msgId]) != null ? _w : messageSeen[msgId] = {};
            messageSeen[msgId].text = true;
          }
          controller.enqueue({
            type: "text-delta",
            delta: text,
            id: msgId
          });
        }
      } else if (isToolMessageType(msg)) {
        const msgObj = msg;
        const dataSource = msgObj.type === "constructor" && msgObj.kwargs && typeof msgObj.kwargs === "object" ? msgObj.kwargs : msgObj;
        const toolCallId = dataSource.tool_call_id;
        const status = dataSource.status;
        if (toolCallId) {
          if (status === "error") {
            controller.enqueue({
              type: "tool-output-error",
              toolCallId,
              errorText: typeof dataSource.content === "string" ? dataSource.content : "Tool execution failed"
            });
          } else {
            controller.enqueue({
              type: "tool-output-available",
              toolCallId,
              output: dataSource.content
            });
          }
        }
      }
      return;
    }
    case "values": {
      for (const [id, seen] of Object.entries(messageSeen)) {
        if (seen.text) controller.enqueue({ type: "text-end", id });
        if (seen.tool) {
          for (const [toolCallId, toolCallSeen] of Object.entries(seen.tool)) {
            const concatMsg = messageConcat[id];
            const toolCall = (_x = concatMsg == null ? void 0 : concatMsg.tool_calls) == null ? void 0 : _x.find(
              (call) => call.id === toolCallId
            );
            if (toolCallSeen && toolCall) {
              emittedToolCalls.add(toolCallId);
              const toolCallKey = `${toolCall.name}:${JSON.stringify(toolCall.args)}`;
              emittedToolCallsByKey.set(toolCallKey, toolCallId);
              controller.enqueue({
                type: "tool-input-available",
                toolCallId,
                toolName: toolCall.name,
                input: toolCall.args,
                dynamic: true
              });
            }
          }
        }
        if (seen.reasoning) {
          controller.enqueue({ type: "reasoning-end", id });
        }
        delete messageSeen[id];
        delete messageConcat[id];
        delete messageReasoningIds[id];
      }
      if (data != null && typeof data === "object" && "messages" in data) {
        const messages = data.messages;
        if (Array.isArray(messages)) {
          const completedToolCallIds = /* @__PURE__ */ new Set();
          for (const msg of messages) {
            if (!msg || typeof msg !== "object") continue;
            if (isToolMessageType(msg)) {
              const msgObj = msg;
              const dataSource = msgObj.type === "constructor" && msgObj.kwargs && typeof msgObj.kwargs === "object" ? msgObj.kwargs : msgObj;
              const toolCallId = dataSource.tool_call_id;
              if (toolCallId) {
                completedToolCallIds.add(toolCallId);
              }
            }
          }
          for (const msg of messages) {
            if (!msg || typeof msg !== "object") continue;
            const msgId = getMessageId(msg);
            if (!msgId) continue;
            let toolCalls;
            if (AIMessageChunk.isInstance(msg) || AIMessage.isInstance(msg)) {
              toolCalls = msg.tool_calls;
            } else if (isPlainMessageObject(msg)) {
              const obj = msg;
              const isSerializedFormat = obj.type === "constructor" && Array.isArray(obj.id) && (obj.id.includes("AIMessageChunk") || obj.id.includes("AIMessage"));
              const dataSource = isSerializedFormat ? obj.kwargs : obj;
              if (obj.type === "ai" || isSerializedFormat) {
                if (Array.isArray(dataSource == null ? void 0 : dataSource.tool_calls)) {
                  toolCalls = dataSource.tool_calls;
                } else if (
                  /**
                   * Fall back to additional_kwargs.tool_calls (OpenAI format)
                   */
                  (dataSource == null ? void 0 : dataSource.additional_kwargs) && typeof dataSource.additional_kwargs === "object"
                ) {
                  const additionalKwargs = dataSource.additional_kwargs;
                  if (Array.isArray(additionalKwargs.tool_calls)) {
                    toolCalls = additionalKwargs.tool_calls.map((tc, idx) => {
                      const functionData = tc.function;
                      let args;
                      try {
                        args = (functionData == null ? void 0 : functionData.arguments) ? JSON.parse(functionData.arguments) : {};
                      } catch (e) {
                        args = {};
                      }
                      return {
                        id: tc.id || `call_${idx}`,
                        name: (functionData == null ? void 0 : functionData.name) || "unknown",
                        args
                      };
                    });
                  }
                }
              }
            }
            if (toolCalls && toolCalls.length > 0) {
              for (const toolCall of toolCalls) {
                if (toolCall.id && !emittedToolCalls.has(toolCall.id) && !completedToolCallIds.has(toolCall.id)) {
                  emittedToolCalls.add(toolCall.id);
                  const toolCallKey = `${toolCall.name}:${JSON.stringify(toolCall.args)}`;
                  emittedToolCallsByKey.set(toolCallKey, toolCall.id);
                  controller.enqueue({
                    type: "tool-input-start",
                    toolCallId: toolCall.id,
                    toolName: toolCall.name,
                    dynamic: true
                  });
                  controller.enqueue({
                    type: "tool-input-available",
                    toolCallId: toolCall.id,
                    toolName: toolCall.name,
                    input: toolCall.args,
                    dynamic: true
                  });
                }
              }
            }
            const reasoningId = extractReasoningId(msg);
            const wasStreamedThisRequest = !!messageSeen[msgId];
            const hasToolCalls = toolCalls && toolCalls.length > 0;
            const shouldEmitReasoning = reasoningId && !emittedReasoningIds.has(reasoningId) && (wasStreamedThisRequest || !hasToolCalls);
            if (shouldEmitReasoning) {
              const reasoning = extractReasoningFromValuesMessage(msg);
              if (reasoning) {
                controller.enqueue({ type: "reasoning-start", id: msgId });
                controller.enqueue({
                  type: "reasoning-delta",
                  delta: reasoning,
                  id: msgId
                });
                controller.enqueue({ type: "reasoning-end", id: msgId });
                emittedReasoningIds.add(reasoningId);
              }
            }
          }
        }
      }
      if (data != null && typeof data === "object") {
        const interrupt = data.__interrupt__;
        if (Array.isArray(interrupt) && interrupt.length > 0) {
          for (const interruptItem of interrupt) {
            const interruptValue = interruptItem == null ? void 0 : interruptItem.value;
            if (!interruptValue) continue;
            const actionRequests = interruptValue.actionRequests || interruptValue.action_requests;
            if (!Array.isArray(actionRequests)) continue;
            for (const actionRequest of actionRequests) {
              const toolName = actionRequest.name;
              const input = actionRequest.args || actionRequest.arguments;
              const toolCallKey = `${toolName}:${JSON.stringify(input)}`;
              const toolCallId = emittedToolCallsByKey.get(toolCallKey) || actionRequest.id || `hitl-${toolName}-${Date.now()}`;
              if (!emittedToolCalls.has(toolCallId)) {
                emittedToolCalls.add(toolCallId);
                emittedToolCallsByKey.set(toolCallKey, toolCallId);
                controller.enqueue({
                  type: "tool-input-start",
                  toolCallId,
                  toolName,
                  dynamic: true
                });
                controller.enqueue({
                  type: "tool-input-available",
                  toolCallId,
                  toolName,
                  input,
                  dynamic: true
                });
              }
              controller.enqueue({
                type: "tool-approval-request",
                approvalId: toolCallId,
                toolCallId
              });
            }
          }
        }
      }
      break;
    }
  }
}

// src/adapter.ts
async function toBaseMessages(messages) {
  const modelMessages = await convertToModelMessages(messages);
  return convertModelMessages(modelMessages);
}
function convertModelMessages(modelMessages) {
  const result = [];
  for (const message of modelMessages) {
    switch (message.role) {
      case "tool": {
        for (const item of message.content) {
          if (isToolResultPart(item)) {
            result.push(convertToolResultPart(item));
          }
        }
        break;
      }
      case "assistant": {
        result.push(convertAssistantContent(message.content));
        break;
      }
      case "system": {
        result.push(new SystemMessage({ content: message.content }));
        break;
      }
      case "user": {
        result.push(convertUserContent(message.content));
        break;
      }
    }
  }
  return result;
}
function isStreamEventsEvent(value) {
  if (value == null || typeof value !== "object") return false;
  const obj = value;
  if (!("event" in obj) || typeof obj.event !== "string") return false;
  if (!("data" in obj)) return false;
  return obj.data === null || typeof obj.data === "object";
}
function processStreamEventsEvent(event, state, controller) {
  var _a, _b, _c;
  if (event.run_id && !state.started) {
    state.messageId = event.run_id;
  }
  if (!event.data) return;
  switch (event.event) {
    case "on_chat_model_start": {
      const runId = event.run_id || event.data.run_id;
      if (runId) {
        state.messageId = runId;
      }
      break;
    }
    case "on_chat_model_stream": {
      const chunk = event.data.chunk;
      if (chunk && typeof chunk === "object") {
        const chunkId = chunk.id;
        if (chunkId) {
          state.messageId = chunkId;
        }
        const reasoning = extractReasoningFromContentBlocks(chunk);
        if (reasoning) {
          if (!state.reasoningStarted) {
            state.reasoningMessageId = state.messageId;
            controller.enqueue({
              type: "reasoning-start",
              id: state.messageId
            });
            state.reasoningStarted = true;
            state.started = true;
          }
          controller.enqueue({
            type: "reasoning-delta",
            delta: reasoning,
            id: (_a = state.reasoningMessageId) != null ? _a : state.messageId
          });
        }
        const content = chunk.content;
        const text = typeof content === "string" ? content : Array.isArray(content) ? content.filter(
          (c) => typeof c === "object" && c !== null && "type" in c && c.type === "text"
        ).map((c) => c.text).join("") : "";
        if (text) {
          if (state.reasoningStarted && !state.textStarted) {
            controller.enqueue({
              type: "reasoning-end",
              id: (_b = state.reasoningMessageId) != null ? _b : state.messageId
            });
            state.reasoningStarted = false;
          }
          if (!state.textStarted) {
            state.textMessageId = state.messageId;
            controller.enqueue({ type: "text-start", id: state.messageId });
            state.textStarted = true;
            state.started = true;
          }
          controller.enqueue({
            type: "text-delta",
            delta: text,
            id: (_c = state.textMessageId) != null ? _c : state.messageId
          });
        }
      }
      break;
    }
    case "on_tool_start": {
      const runId = event.run_id || event.data.run_id;
      const name = event.name || event.data.name;
      if (runId && name) {
        controller.enqueue({
          type: "tool-input-start",
          toolCallId: runId,
          toolName: name,
          dynamic: true
        });
      }
      break;
    }
    case "on_tool_end": {
      const runId = event.run_id || event.data.run_id;
      const output = event.data.output;
      if (runId) {
        controller.enqueue({
          type: "tool-output-available",
          toolCallId: runId,
          output
        });
      }
      break;
    }
  }
}
function toUIMessageStream(stream, callbacks) {
  const textChunks = [];
  const modelState = {
    started: false,
    messageId: "langchain-msg-1",
    reasoningStarted: false,
    textStarted: false,
    /** Track the ID used for text-start to ensure text-end uses the same ID */
    textMessageId: null,
    /** Track the ID used for reasoning-start to ensure reasoning-end uses the same ID */
    reasoningMessageId: null
  };
  const langGraphState = {
    messageSeen: {},
    messageConcat: {},
    emittedToolCalls: /* @__PURE__ */ new Set(),
    emittedImages: /* @__PURE__ */ new Set(),
    emittedReasoningIds: /* @__PURE__ */ new Set(),
    messageReasoningIds: {},
    toolCallInfoByIndex: {},
    currentStep: null,
    emittedToolCallsByKey: /* @__PURE__ */ new Map()
  };
  let streamType = null;
  const getAsyncIterator = () => {
    if (Symbol.asyncIterator in stream) {
      return stream[Symbol.asyncIterator]();
    }
    const reader = stream.getReader();
    return {
      async next() {
        const { done, value } = await reader.read();
        return { done, value };
      }
    };
  };
  const iterator = getAsyncIterator();
  const createCallbackController = (originalController) => {
    return {
      get desiredSize() {
        return originalController.desiredSize;
      },
      close: () => originalController.close(),
      error: (e) => originalController.error(e),
      enqueue: (chunk) => {
        var _a, _b;
        if (callbacks && chunk.type === "text-delta" && chunk.delta) {
          textChunks.push(chunk.delta);
          (_a = callbacks.onToken) == null ? void 0 : _a.call(callbacks, chunk.delta);
          (_b = callbacks.onText) == null ? void 0 : _b.call(callbacks, chunk.delta);
        }
        originalController.enqueue(chunk);
      }
    };
  };
  return new ReadableStream({
    async start(controller) {
      var _a, _b, _c, _d;
      await ((_a = callbacks == null ? void 0 : callbacks.onStart) == null ? void 0 : _a.call(callbacks));
      const wrappedController = createCallbackController(controller);
      controller.enqueue({ type: "start" });
      try {
        while (true) {
          const { done, value } = await iterator.next();
          if (done) break;
          if (streamType === null) {
            if (Array.isArray(value)) {
              streamType = "langgraph";
            } else if (isStreamEventsEvent(value)) {
              streamType = "streamEvents";
            } else {
              streamType = "model";
            }
          }
          if (streamType === "model") {
            processModelChunk(
              value,
              modelState,
              wrappedController
            );
          } else if (streamType === "streamEvents") {
            processStreamEventsEvent(
              value,
              modelState,
              wrappedController
            );
          } else {
            processLangGraphEvent(
              value,
              langGraphState,
              wrappedController
            );
          }
        }
        if (streamType === "model" || streamType === "streamEvents") {
          if (modelState.reasoningStarted) {
            controller.enqueue({
              type: "reasoning-end",
              id: (_b = modelState.reasoningMessageId) != null ? _b : modelState.messageId
            });
          }
          if (modelState.textStarted) {
            controller.enqueue({
              type: "text-end",
              id: (_c = modelState.textMessageId) != null ? _c : modelState.messageId
            });
          }
          controller.enqueue({ type: "finish" });
        } else if (streamType === "langgraph") {
          if (langGraphState.currentStep !== null) {
            controller.enqueue({ type: "finish-step" });
          }
          controller.enqueue({ type: "finish" });
        }
        await ((_d = callbacks == null ? void 0 : callbacks.onFinal) == null ? void 0 : _d.call(callbacks, textChunks.join("")));
      } catch (error) {
        controller.enqueue({
          type: "error",
          errorText: error instanceof Error ? error.message : "Unknown error"
        });
      } finally {
        controller.close();
      }
    }
  });
}

// src/transport.ts
import {
  RemoteGraph
} from "@langchain/langgraph/remote";
var LangSmithDeploymentTransport = class {
  constructor(options) {
    var _a;
    this.graph = new RemoteGraph({
      ...options,
      graphId: (_a = options.graphId) != null ? _a : "agent"
    });
  }
  async sendMessages(options) {
    const baseMessages = await toBaseMessages(options.messages);
    const stream = await this.graph.stream(
      { messages: baseMessages },
      { streamMode: ["values", "messages"] }
    );
    return toUIMessageStream(
      stream
    );
  }
  async reconnectToStream(_options) {
    throw new Error("Method not implemented.");
  }
};
export {
  LangSmithDeploymentTransport,
  convertModelMessages,
  toBaseMessages,
  toUIMessageStream
};
//# sourceMappingURL=index.mjs.map